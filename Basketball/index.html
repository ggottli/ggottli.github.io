<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Enhanced 3D 2-on-2 Basketball Game</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #333;
      }
      canvas {
        display: block;
        margin: auto;
        /* A vertical gradient adds some depth to the court */
        background: linear-gradient(#7ec850, #5aa642);
      }
    </style>
  </head>
  <body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
    <script>
      // =============================
      // Setup & Global Constants
      // =============================
      const canvas = document.getElementById("gameCanvas");
      const ctx = canvas.getContext("2d");
      const COURT_WIDTH = canvas.width;
      const COURT_HEIGHT = canvas.height;

      // Game constants
      const PLAYER_RADIUS = 15;
      const BALL_RADIUS = 8;
      const NORMAL_SPEED = 2;
      const SPRINT_SPEED = 4;
      const SPRINT_DURATION = 500; // ms
      const PASS_TIME = 500; // ms for passes
      const SHOOT_FLIGHT_TIME = 1000; // ms for shot flight
      const GRAVITY = 0.0015; // pixels/msÂ² (for the shot arc)
      const THREE_POINT_RADIUS = 150; // pixels from hoop
      // Rebound lock time: after a missed shot, the ball cannot be picked up immediately.
      const REBOUND_LOCK_TIME = 300; // ms

      // =============================
      // Classes
      // =============================
      
      // --- Player Class ---
      class Player {
        constructor(x, y, team) {
          this.x = x;
          this.y = y;
          this.team = team; // "blue" or "red"
          this.vx = 0;
          this.vy = 0;
          this.hasBall = false;
          this.speed = NORMAL_SPEED;
          this.sprintTime = 0;
        }
        update(delta) {
          this.x += this.vx * this.speed;
          this.y += this.vy * this.speed;
          // Clamp player inside the court
          this.x = Math.max(PLAYER_RADIUS, Math.min(COURT_WIDTH - PLAYER_RADIUS, this.x));
          this.y = Math.max(PLAYER_RADIUS, Math.min(COURT_HEIGHT - PLAYER_RADIUS, this.y));
          if (this.sprintTime > 0) {
            this.sprintTime -= delta;
            if (this.sprintTime <= 0) this.speed = NORMAL_SPEED;
          }
        }
        draw(ctx) {
          // Draw player shadow
          ctx.beginPath();
          ctx.ellipse(this.x, this.y + PLAYER_RADIUS * 0.5, PLAYER_RADIUS, PLAYER_RADIUS * 0.5, 0, 0, Math.PI * 2);
          ctx.fillStyle = "rgba(0,0,0,0.3)";
          ctx.fill();
          // Draw player body with a radial gradient for a 3D look
          let grad = ctx.createRadialGradient(this.x, this.y - 5, PLAYER_RADIUS * 0.3, this.x, this.y - 5, PLAYER_RADIUS);
          if (this.team === "blue") {
            grad.addColorStop(0, "#99ccff");
            grad.addColorStop(1, "#0000ff");
          } else {
            grad.addColorStop(0, "#ff9999");
            grad.addColorStop(1, "#ff0000");
          }
          ctx.beginPath();
          ctx.arc(this.x, this.y, PLAYER_RADIUS, 0, Math.PI * 2);
          ctx.fillStyle = grad;
          ctx.fill();
          // If holding the ball, draw an outline.
          if (this.hasBall) {
            ctx.lineWidth = 3;
            ctx.strokeStyle = "#fff";
            ctx.stroke();
          }
        }
      }

      // --- Ball Class ---
      class Ball {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.vx = 0;
          this.vy = 0;
          // The ball state can be:
          // "held" (attached to a player),
          // "in-flight" (for passes),
          // "shot" (in a shot arc),
          // "loose" (available for rebound),
          // "scored" (after a made shot)
          this.state = "held";
          this.holder = null;
          // For shot arc simulation (vertical motion)
          this.z = 0;
          this.vz = 0;
          // For shot outcome details.
          this.shotAttempt = false;
          this.shotTeam = null;
          this.shotValue = 0;
          this.shotProbability = 0;
          // Prevent immediate pickup after a missed shot.
          this.reboundLock = false;
        }
        update(delta) {
          if (this.state === "shot") {
            // Update horizontal positions
            this.x += this.vx * delta;
            this.y += this.vy * delta;
            // Update vertical (z) position with simple physics.
            this.z += this.vz * delta - 0.5 * GRAVITY * delta * delta;
            this.vz -= GRAVITY * delta;
            if (this.z <= 0) {
              this.z = 0;
              // Process shot outcome (only once)
              if (this.shotAttempt) {
                processShotOutcome();
              }
            }
          } else if (this.state === "in-flight") {
            // For passes.
            this.x += this.vx * delta;
            this.y += this.vy * delta;
            if (this.x < 0 || this.x > COURT_WIDTH || this.y < 0 || this.y > COURT_HEIGHT) {
              this.state = "loose";
              this.vx = this.vy = 0;
            }
          } else if (this.state === "held" && this.holder) {
            // Follow the holder.
            this.x = this.holder.x;
            this.y = this.holder.y;
            this.z = 0;
          }
          // (When state is "loose" or "scored", physics are handled elsewhere.)
        }
        draw(ctx) {
          if (this.state === "shot") {
            // Draw shadow on the court
            ctx.beginPath();
            ctx.ellipse(this.x, this.y, BALL_RADIUS * 1.2, BALL_RADIUS * 0.6, 0, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(0,0,0,0.3)";
            ctx.fill();
            // Draw ball elevated (offset by z)
            let drawX = this.x;
            let drawY = this.y - this.z;
            let grad = ctx.createRadialGradient(drawX, drawY, BALL_RADIUS * 0.3, drawX, drawY, BALL_RADIUS);
            grad.addColorStop(0, "#FFF200");
            grad.addColorStop(1, "#FFA500");
            ctx.beginPath();
            ctx.arc(drawX, drawY, BALL_RADIUS, 0, Math.PI * 2);
            ctx.fillStyle = grad;
            ctx.fill();
            ctx.strokeStyle = "#000";
            ctx.stroke();
          } else {
            // Draw ball on the ground (for passes or held)
            ctx.beginPath();
            ctx.ellipse(this.x, this.y, BALL_RADIUS * 1.2, BALL_RADIUS * 0.6, 0, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(0,0,0,0.3)";
            ctx.fill();
            ctx.beginPath();
            ctx.arc(this.x, this.y, BALL_RADIUS, 0, Math.PI * 2);
            ctx.fillStyle = "#FFA500";
            ctx.fill();
            ctx.strokeStyle = "#000";
            ctx.stroke();
          }
        }
      }

      // =============================
      // Create Game Objects
      // =============================
      
      const players = [];
      // Blue team (user-controlled and CPU teammate)
      const blue1 = new Player(200, COURT_HEIGHT / 2 - 50, "blue");
      const blue2 = new Player(200, COURT_HEIGHT / 2 + 50, "blue");
      players.push(blue1, blue2);
      // Red team (CPU opponents)
      const red1 = new Player(COURT_WIDTH - 200, COURT_HEIGHT / 2 - 50, "red");
      const red2 = new Player(COURT_WIDTH - 200, COURT_HEIGHT / 2 + 50, "red");
      players.push(red1, red2);

      // Start with blue1 holding the ball.
      const ball = new Ball(blue1.x, blue1.y);
      ball.state = "held";
      ball.holder = blue1;
      blue1.hasBall = true;

      // =============================
      // Game State Variables
      // =============================
      let blueScore = 0;
      let redScore = 0;
      let currentQuarter = 1;
      let quarterTime = 60 * 1000; // 1 minute per quarter (in ms)
      let lastTime = performance.now();

      // =============================
      // Input Handling
      // =============================
      const keys = {};
      window.addEventListener("keydown", (e) => {
        keys[e.key] = true;
        if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].includes(e.key)) {
          e.preventDefault();
        }
      });
      window.addEventListener("keyup", (e) => {
        keys[e.key] = false;
      });

      // =============================
      // Utility Functions
      // =============================
      
      // Choose which blue player to control:
      // If one has the ball, control that one; otherwise, pick the one closest to the ball.
      function getControlledPlayer() {
        if (blue1.hasBall) return blue1;
        if (blue2.hasBall) return blue2;
        const d1 = Math.hypot(blue1.x - ball.x, blue1.y - ball.y);
        const d2 = Math.hypot(blue2.x - ball.x, blue2.y - ball.y);
        return d1 < d2 ? blue1 : blue2;
      }
      
      // Returns true if blue team is on offense.
      function isBlueOffense() {
        return blue1.hasBall || blue2.hasBall;
      }
      
      // After a made shot, award possession to a random player on the specified team.
      function resetPossession(team) {
        const candidates = players.filter(p => p.team === team);
        if (candidates.length === 0) return;
        const chosen = candidates[Math.floor(Math.random() * candidates.length)];
        ball.state = "held";
        ball.holder = chosen;
        chosen.hasBall = true;
        ball.x = chosen.x;
        ball.y = chosen.y;
      }
      
      // Process the outcome of a shot.
      function processShotOutcome() {
        if (!ball.shotAttempt) return; // Only process once.
        if (Math.random() < ball.shotProbability) {
          // Made shot.
          ball.state = "scored";
          if (ball.shotTeam === "blue") {
            blueScore += ball.shotValue;
            // Award ball to red after a brief delay.
            setTimeout(() => { resetPossession("red"); }, 1000);
          } else {
            redScore += ball.shotValue;
            setTimeout(() => { resetPossession("blue"); }, 1000);
          }
        } else {
          // Missed shot: enable a rebound bounce.
          ball.state = "loose";
          ball.reboundLock = true;
          // Remove rebound lock after a short delay so players can then grab the ball.
          setTimeout(() => { ball.reboundLock = false; }, REBOUND_LOCK_TIME);
        }
        ball.shotAttempt = false;
      }
      
      // =============================
      // AI Functions (CPU Behavior)
      // =============================
      function updateAI(player, delta) {
        // Skip user-controlled blue player.
        const controlled = getControlledPlayer();
        if (player.team === "blue" && player === controlled) return;
      
        // Determine if this team is on offense.
        let teamOffense = (player.team === "blue")
          ? (blue1.hasBall || blue2.hasBall)
          : (red1.hasBall || red2.hasBall);
      
        if (player.hasBall) {
          // Aggressive offense.
          const hoop = (player.team === "blue")
            ? { x: COURT_WIDTH - 50, y: COURT_HEIGHT / 2 }
            : { x: 150, y: COURT_HEIGHT / 2 };
          const distToHoop = Math.hypot(player.x - hoop.x, player.y - hoop.y);
          // If a teammate is in a better position, sometimes pass.
          let teammates = players.filter(p => p.team === player.team && p !== player);
          if (teammates.length > 0) {
            let teammate = teammates[0];
            let teammateDist = Math.hypot(teammate.x - hoop.x, teammate.y - hoop.y);
            if (teammateDist + 20 < distToHoop && Math.random() < 0.5) {
              passBall(player);
              return;
            }
          }
          // If very close, shoot with high chance.
          if (distToHoop < 120) {
            if (Math.random() < 0.7) {
              shootBall(player);
              return;
            } else {
              // Otherwise, drive in further.
              let angle = Math.atan2(hoop.y - player.y, hoop.x - player.x);
              player.vx = Math.cos(angle);
              player.vy = Math.sin(angle);
            }
          } else {
            // Drive toward the hoop.
            let angle = Math.atan2(hoop.y - player.y, hoop.x - player.x);
            player.vx = Math.cos(angle);
            player.vy = Math.sin(angle);
          }
        } else {
          // When not holding the ball.
          if (ball.state === "held" && ball.holder && ball.holder.team !== player.team) {
            // Chase the opponent who has the ball.
            let angle = Math.atan2(ball.holder.y - player.y, ball.holder.x - player.x);
            player.vx = Math.cos(angle);
            player.vy = Math.sin(angle);
            // Attempt a steal if close.
            if (Math.hypot(player.x - ball.holder.x, player.y - ball.holder.y) < 30) {
              attemptSteal(player);
            }
          } else if (ball.state === "shot") {
            // Try to block a shot.
            let angle = Math.atan2(ball.y - player.y, ball.x - player.x);
            player.vx = Math.cos(angle);
            player.vy = Math.sin(angle);
            if (Math.hypot(player.x - ball.x, player.y - ball.y) < 50) {
              attemptBlock(player);
            }
          } else {
            // Otherwise, chase the loose ball.
            let angle = Math.atan2(ball.y - player.y, ball.x - player.x);
            player.vx = Math.cos(angle);
            player.vy = Math.sin(angle);
          }
        }
        // --- Separation: Avoid overlapping with teammates.
        let sepX = 0, sepY = 0;
        for (let other of players) {
          if (other !== player && other.team === player.team) {
            let d = Math.hypot(player.x - other.x, player.y - other.y);
            if (d < PLAYER_RADIUS * 2) {
              sepX += (player.x - other.x) / d;
              sepY += (player.y - other.y) / d;
            }
          }
        }
        player.vx += sepX * 0.5;
        player.vy += sepY * 0.5;
        let len = Math.hypot(player.vx, player.vy);
        if (len > 0) {
          player.vx /= len;
          player.vy /= len;
        }
      }
      
      // =============================
      // Action Functions
      // =============================
      function shootBall(player) {
        if (!player.hasBall) return;
        const hoop = (player.team === "blue")
          ? { x: COURT_WIDTH - 50, y: COURT_HEIGHT / 2 }
          : { x: 150, y: COURT_HEIGHT / 2 };
        ball.state = "shot";
        ball.holder = null;
        ball.shotAttempt = true;
        ball.shotTeam = player.team;
        player.hasBall = false;
        // Set horizontal velocities so that the ball reaches the hoop in SHOOT_FLIGHT_TIME ms.
        ball.vx = (hoop.x - player.x) / SHOOT_FLIGHT_TIME;
        ball.vy = (hoop.y - player.y) / SHOOT_FLIGHT_TIME;
        ball.z = 0;
        ball.vz = 0.5 * GRAVITY * SHOOT_FLIGHT_TIME;
        // Calculate distance to hoop and determine shot value/probability.
        let dist = Math.hypot(hoop.x - player.x, hoop.y - player.y);
        if (dist < THREE_POINT_RADIUS) {
          ball.shotValue = 2;
          let effectiveDistance = Math.max(dist, 50);
          ball.shotProbability = Math.max(0.5, 0.7 - 0.2 * ((effectiveDistance - 50) / 100));
        } else {
          ball.shotValue = 3;
          let effectiveDistance = Math.max(dist, THREE_POINT_RADIUS);
          ball.shotProbability = Math.max(0.3, 0.5 - 0.2 * ((effectiveDistance - THREE_POINT_RADIUS) / (300 - THREE_POINT_RADIUS)));
        }
      }
      
      function passBall(player) {
        if (!player.hasBall) return;
        let teammates = players.filter(p => p.team === player.team && p !== player);
        if (teammates.length === 0) return;
        let teammate = teammates[0];
        ball.state = "in-flight";
        ball.holder = null;
        player.hasBall = false;
        let dx = teammate.x - player.x;
        let dy = teammate.y - player.y;
        let dist = Math.hypot(dx, dy);
        // Avoid division by zero.
        if (dist < 1) { ball.vx = ball.vy = 0; }
        else {
          ball.vx = dx / PASS_TIME;
          ball.vy = dy / PASS_TIME;
        }
      }
      
      function attemptSteal(defender) {
        let opponent = defender.team === "blue" ? (red1.hasBall ? red1 : red2)
                                                : (blue1.hasBall ? blue1 : blue2);
        if (!opponent || !opponent.hasBall) return;
        let distance = Math.hypot(defender.x - opponent.x, defender.y - opponent.y);
        if (distance < 30) {
          opponent.hasBall = false;
          ball.holder = defender;
          ball.state = "held";
          defender.hasBall = true;
        }
      }
      
      function attemptBlock(defender) {
        if (ball.state !== "shot") return;
        let distance = Math.hypot(defender.x - ball.x, defender.y - ball.y);
        if (distance < 30) {
          ball.state = "loose";
          ball.vx = ball.vy = ball.vz = 0;
        }
      }
      
      function sprint(player) {
        player.speed = SPRINT_SPEED;
        player.sprintTime = SPRINT_DURATION;
      }
      
      // =============================
      // Drawing Functions
      // =============================
      function drawHoop(x, y) {
        ctx.save();
        ctx.translate(x, y);
        ctx.beginPath();
        ctx.ellipse(0, 0, 20, 10, 0, 0, Math.PI * 2);
        ctx.fillStyle = "#FF4500";
        ctx.fill();
        ctx.strokeStyle = "#000";
        ctx.stroke();
        // Draw some net lines.
        ctx.strokeStyle = "rgba(255,255,255,0.7)";
        for (let angle = 210; angle < 330; angle += 30) {
          let rad = (angle * Math.PI) / 180;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(20 * Math.cos(rad), 20 * Math.sin(rad));
          ctx.stroke();
        }
        ctx.restore();
      }
      
      function drawThreePointLines() {
        ctx.strokeStyle = "#fff";
        ctx.setLineDash([5, 5]);
        // Left hoop.
        ctx.beginPath();
        ctx.arc(50, COURT_HEIGHT / 2, THREE_POINT_RADIUS, 0, Math.PI * 2);
        ctx.stroke();
        // Right hoop.
        ctx.beginPath();
        ctx.arc(COURT_WIDTH - 50, COURT_HEIGHT / 2, THREE_POINT_RADIUS, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
      }
      
      // =============================
      // Main Game Loop
      // =============================
      function gameLoop(timestamp) {
        let delta = timestamp - lastTime;
        lastTime = timestamp;
      
        // Update quarter timer.
        quarterTime -= delta;
        if (quarterTime <= 0) {
          currentQuarter++;
          if (currentQuarter > 4) {
            alert("Game Over!\nFinal Score - Blue: " + blueScore + "   Red: " + redScore);
            currentQuarter = 1;
            blueScore = redScore = 0;
          }
          quarterTime = 60 * 1000;
          // Reset player positions and ball.
          blue1.x = 200; blue1.y = COURT_HEIGHT / 2 - 50;
          blue2.x = 200; blue2.y = COURT_HEIGHT / 2 + 50;
          red1.x = COURT_WIDTH - 200; red1.y = COURT_HEIGHT / 2 - 50;
          red2.x = COURT_WIDTH - 200; red2.y = COURT_HEIGHT / 2 + 50;
          ball.x = blue1.x; ball.y = blue1.y;
          ball.state = "held";
          ball.holder = blue1;
          blue1.hasBall = true;
          blue2.hasBall = false;
          red1.hasBall = false;
          red2.hasBall = false;
        }
      
        // Clear the canvas.
        ctx.clearRect(0, 0, COURT_WIDTH, COURT_HEIGHT);
      
        // Draw court midline.
        ctx.strokeStyle = "#fff";
        ctx.beginPath();
        ctx.moveTo(COURT_WIDTH / 2, 0);
        ctx.lineTo(COURT_WIDTH / 2, COURT_HEIGHT);
        ctx.stroke();
      
        // Draw 3-point lines and hoops.
        drawThreePointLines();
        drawHoop(50, COURT_HEIGHT / 2);
        drawHoop(COURT_WIDTH - 50, COURT_HEIGHT / 2);
      
        // ---- Process User Input for the Controlled Blue Player ----
        const controlled = getControlledPlayer();
        controlled.vx = controlled.vy = 0;
        if (keys["ArrowUp"]) controlled.vy = -1;
        if (keys["ArrowDown"]) controlled.vy = 1;
        if (keys["ArrowLeft"]) controlled.vx = -1;
        if (keys["ArrowRight"]) controlled.vx = 1;
        if (controlled.vx !== 0 && controlled.vy !== 0) {
          controlled.vx *= Math.SQRT1_2;
          controlled.vy *= Math.SQRT1_2;
        }
        if (keys["x"]) sprint(controlled);
        // Z: shoot on offense or attempt a steal on defense.
        if (keys["z"]) {
          if (isBlueOffense()) {
            if (controlled.hasBall) shootBall(controlled);
          } else {
            attemptSteal(controlled);
          }
          keys["z"] = false;
        }
        // C: pass on offense or attempt a block on defense.
        if (keys["c"]) {
          if (isBlueOffense()) {
            if (controlled.hasBall) passBall(controlled);
          } else {
            attemptBlock(controlled);
          }
          keys["c"] = false;
        }
      
        // ---- Update and Draw All Players ----
        for (let player of players) {
          if (player.team === "blue") {
            if (player !== controlled) updateAI(player, delta);
          } else {
            updateAI(player, delta);
          }
          player.update(delta);
          player.draw(ctx);
        }
      
        // ---- Update and Draw the Ball ----
        ball.update(delta);
        ball.draw(ctx);
      
        // ---- Allow Loose Ball to be Picked Up (after reboundLock expires) ----
        if (ball.state === "loose" && !ball.reboundLock) {
          for (let player of players) {
            let d = Math.hypot(player.x - ball.x, player.y - ball.y);
            if (d < PLAYER_RADIUS + BALL_RADIUS) {
              ball.state = "held";
              ball.holder = player;
              player.hasBall = true;
              break;
            }
          }
        }
      
        // ---- Draw Scoreboard & Clock ----
        ctx.fillStyle = "#000";
        ctx.font = "20px Arial";
        ctx.fillText("Blue: " + blueScore, 20, 30);
        ctx.fillText("Red: " + redScore, COURT_WIDTH - 120, 30);
        ctx.fillText("Quarter: " + currentQuarter, COURT_WIDTH / 2 - 40, 30);
        const seconds = Math.floor(quarterTime / 1000);
        ctx.fillText("Time: " + seconds + "s", COURT_WIDTH / 2 - 40, 60);
      
        requestAnimationFrame(gameLoop);
      }
      
      requestAnimationFrame(gameLoop);
    </script>
  </body>
</html>
